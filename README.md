
a scritp to build nginx + websocket + v2ray quickly.


### 前瞻

#### 问题说明

需要解决的痛点
- 规范日志的格式，消灭因为没有统一的规则而导致无法对日志进行拆分的问题。减少日志分析检索的成本。
- 目前的日志利用率较低，对于日志的利用程度普遍处于检索水平，受限于工具未对日志的价值进一步挖掘，可以挖掘的点，比如日志监控，统计分析，调用链分析。

日志系统的目标：
- 业务日志可以平滑的接入，日志平台只需简单的配置即可进行数据的接入。
- 多样性支持：IDC，虚机，docker，系统日志，业务日志，中间件日志，格式多样，单行，多行，plain，json。
- 日志挖掘：快速可查，日志监控，统计分析，日志告警。
- 可用性：数据实时性，丢失率可控(业务分级，全链路监控)


### 日志等级

- FATAL - 导致程序退出的严重系统级错误，不可恢复，当错误发生时，系统管理员需要立即介入，一般应用代码不使用该日志级别，对应到不同的语言可能级别不同，有可能对应Critical。

- ERROR - 运行时异常以及预期之外的错误，也需要立即处理，但紧急程度低于FATAL。当错误发生时，影响了程序的正确执行。需要注意的是这两种级别属于服务自己的错误，需要管理员介入，用户输入出错不属于此分类，请求后端、读文件、数据库等超时、返回错误结构，属于ERROR

- WARN - 预期之外的运行时状况，表示系统可能出现问题。对于那些目前还不是错误，然而不及时处理也会变成错误的情况，也可以记为WARN，如磁盘过低。

- INFO - 有意义的事件信息，记录程序正常的运行状态，比如收到请求，成功执行。通过查看INFO，可以快速定位WARN，ERROR, FATAL。INFO不宜过多，通常情况下不超过 DEBUG 的10%。

### 规范日志格式

为了规范日志的格式，统一制定日志格式规范，使用JSON作为日志的输出格式，至少需要包含以下几个字段

- time：日志产生时间，可以使用ISO8601格式
- level：日志级别
- appname：当前的应用名称，或者是app_id，目的是用来标识日志的来源，如果存在公司服务树的话要与公司服务树一致。
- info/message：日志详细内容

如果说接口调用类的建议加上`response_time`这样的字段来标明响应的时间。比如下面这样的一跳日志
```json
{
    "message": "Hello World",
    "level": "INFO",
    "appname": "guestplatform",
    "time": "2020-05-09T03:24:02.435083946Z"
}
```

附Python日志级别参考
| Level | Weight |
| --- | --- |
| Critical | 50 |
| Error  | 40 |
|  Warning | 30 |
| info  | 20 |
| debug | 10 |
| unset | 0 |

### 日志约定

- 生产环境禁止输出debug级别的日志

### 日志的采集方式

日志的采集方式分为落盘和非落盘两种方式进行输出，针对当前的考虑，日志的采集统一采用罗盘的方式，后续随着业务的扩大可以单独的开发log agent实现非落盘方式直接将日志内容发送给log agent，由log agent统一采集并发送到日志系统。

同时日志又可以分为`业务日志`，`中间件日志`，`系统日志`。后期业务日志统一以非落盘的形式推送到agent。中间件和系统层日志因为可定制性很低，因此统一采取落盘方式进行收集。

使用filebeat进行采集：
- 使用filebeat对每一类日志打标签。
- 使用filebeat自动标记机器来源。
